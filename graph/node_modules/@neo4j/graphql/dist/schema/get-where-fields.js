"use strict";
/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getWhereFieldsForAttributes = getWhereFieldsForAttributes;
const constants_1 = require("../constants");
const ConcreteEntityAdapter_1 = require("../schema-model/entity/model-adapters/ConcreteEntityAdapter");
const constants_2 = require("./constants");
const utils_1 = require("./generation/utils");
const to_compose_1 = require("./to-compose");
function addCypherFieldFilters({ field, type, result, deprecatedDirectives, features, }) {
    result[field.name] = {
        type,
        directives: deprecatedDirectives,
    };
    if ((0, utils_1.shouldAddDeprecatedFields)(features, "negationFilters")) {
        result[`${field.name}_NOT`] = {
            type,
            directives: deprecatedDirectives.length ? deprecatedDirectives : [constants_2.DEPRECATE_NOT],
        };
    }
}
function addCypherListFieldFilters({ field, type, result, deprecatedDirectives, }) {
    result[`${field.name}_ALL`] = {
        type,
        directives: deprecatedDirectives,
    };
    result[`${field.name}_NONE`] = {
        type,
        directives: deprecatedDirectives,
    };
    result[`${field.name}_SINGLE`] = {
        type,
        directives: deprecatedDirectives,
    };
    result[`${field.name}_SOME`] = {
        type,
        directives: deprecatedDirectives,
    };
}
// TODO: refactoring needed!
// isWhereField, isFilterable, ... extracted out into attributes category
function getWhereFieldsForAttributes({ attributes, userDefinedFieldDirectives, features, ignoreCypherFieldFilters, }) {
    const result = {};
    // Add the where fields for each attribute
    for (const field of attributes) {
        const userDefinedDirectivesOnField = userDefinedFieldDirectives?.get(field.name);
        const deprecatedDirectives = (0, to_compose_1.graphqlDirectivesToCompose)((userDefinedDirectivesOnField ?? []).filter((directive) => directive.name.value === constants_1.DEPRECATED));
        if (field.annotations.cypher) {
            // If the field is a cypher field and ignoreCypherFieldFilters is true, skip it
            if (ignoreCypherFieldFilters === true) {
                continue;
            }
            // If the field is a cypher field with arguments, skip it
            if (field.args.length > 0) {
                continue;
            }
            if (field.annotations.cypher.targetEntity) {
                const targetEntityAdapter = new ConcreteEntityAdapter_1.ConcreteEntityAdapter(field.annotations.cypher.targetEntity);
                const type = targetEntityAdapter.operations.whereInputTypeName;
                // Always add base where field filters (e.g. name, name_NOT)
                addCypherFieldFilters({
                    field,
                    type,
                    result,
                    deprecatedDirectives,
                    features,
                });
                // Add list where field filters (e.g. name_ALL, name_NONE, name_SINGLE, name_SOME)
                if (field.typeHelper.isList()) {
                    addCypherListFieldFilters({
                        field,
                        type,
                        result,
                        deprecatedDirectives,
                    });
                }
                continue;
            }
        }
        result[field.name] = {
            type: field.getInputTypeNames().where.pretty,
            directives: deprecatedDirectives,
        };
        if ((0, utils_1.shouldAddDeprecatedFields)(features, "negationFilters")) {
            result[`${field.name}_NOT`] = {
                type: field.getInputTypeNames().where.pretty,
                directives: deprecatedDirectives.length ? deprecatedDirectives : [constants_2.DEPRECATE_NOT],
            };
        }
        // If the field is a boolean, skip it
        // This is done here because the previous additions are still added for boolean fields
        if (field.typeHelper.isBoolean()) {
            continue;
        }
        // If the field is an array, add the includes and not includes fields
        // if (field.isArray()) {
        if (field.typeHelper.isList()) {
            result[`${field.name}_INCLUDES`] = {
                type: field.getInputTypeNames().where.type,
                directives: deprecatedDirectives,
            };
            if ((0, utils_1.shouldAddDeprecatedFields)(features, "negationFilters")) {
                result[`${field.name}_NOT_INCLUDES`] = {
                    type: field.getInputTypeNames().where.type,
                    directives: deprecatedDirectives.length ? deprecatedDirectives : [constants_2.DEPRECATE_NOT],
                };
            }
            continue;
        }
        // If the field is not an array, add the in and not in fields
        result[`${field.name}_IN`] = {
            type: field.getFilterableInputTypeName(),
            directives: deprecatedDirectives,
        };
        if ((0, utils_1.shouldAddDeprecatedFields)(features, "negationFilters")) {
            result[`${field.name}_NOT_IN`] = {
                type: field.getFilterableInputTypeName(),
                directives: deprecatedDirectives.length ? deprecatedDirectives : [constants_2.DEPRECATE_NOT],
            };
        }
        // If the field is a number or temporal, add the comparison operators
        if (field.isNumericalOrTemporal()) {
            ["_LT", "_LTE", "_GT", "_GTE"].forEach((comparator) => {
                result[`${field.name}${comparator}`] = {
                    type: field.getInputTypeNames().where.type,
                    directives: deprecatedDirectives,
                };
            });
            continue;
        }
        // If the field is spatial, add the point comparison operators
        if (field.typeHelper.isSpatial()) {
            ["_DISTANCE", "_LT", "_LTE", "_GT", "_GTE"].forEach((comparator) => {
                result[`${field.name}${comparator}`] = {
                    type: `${field.getTypeName()}Distance`,
                    directives: deprecatedDirectives,
                };
            });
            continue;
        }
        // If the field is a string, add the string comparison operators
        if (field.typeHelper.isString() || field.typeHelper.isID()) {
            const stringWhereOperators = [
                { comparator: "_CONTAINS", typeName: field.getInputTypeNames().where.type },
                { comparator: "_STARTS_WITH", typeName: field.getInputTypeNames().where.type },
                { comparator: "_ENDS_WITH", typeName: field.getInputTypeNames().where.type },
            ];
            Object.entries(features?.filters?.[field.getInputTypeNames().where.type] || {}).forEach(([filter, enabled]) => {
                if (enabled) {
                    if (filter === "MATCHES") {
                        stringWhereOperators.push({ comparator: `_${filter}`, typeName: "String" });
                    }
                    else {
                        stringWhereOperators.push({
                            comparator: `_${filter}`,
                            typeName: field.getInputTypeNames().where.type,
                        });
                    }
                }
            });
            stringWhereOperators.forEach(({ comparator, typeName }) => {
                result[`${field.name}${comparator}`] = { type: typeName, directives: deprecatedDirectives };
            });
            if ((0, utils_1.shouldAddDeprecatedFields)(features, "negationFilters")) {
                ["_NOT_CONTAINS", "_NOT_STARTS_WITH", "_NOT_ENDS_WITH"].forEach((comparator) => {
                    result[`${field.name}${comparator}`] = {
                        type: field.getInputTypeNames().where.type,
                        directives: deprecatedDirectives.length ? deprecatedDirectives : [constants_2.DEPRECATE_NOT],
                    };
                });
            }
        }
    }
    return result;
}
//# sourceMappingURL=get-where-fields.js.map